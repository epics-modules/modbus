<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Driver architecture &mdash; EPICS support for Modbus</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/my_theme.css?v=254ed751" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=5929fcd5"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Creating a modbus port driver" href="creating_driver.html" />
    <link rel="prev" title="Overview of Modbus" href="overview.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            modbus
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="acknowledgments.html">Acknowledgments</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview of Modbus</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Driver architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#modbus-read-functions">Modbus read functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modbus-write-functions">Modbus write functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modbus-write-read-functions">Modbus write/read functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#platform-independence">Platform independence</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="creating_driver.html">Creating a <strong>modbus</strong> port driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_support.html">EPICS device support</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_applications.html">Example Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="medm_screens.html">medm screens</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debug tracing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">modbus</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Driver architecture</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/driver_architecture.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="driver-architecture">
<h1>Driver architecture<a class="headerlink" href="#driver-architecture" title="Link to this heading"></a></h1>
<p><strong>CAUTION:</strong> <strong>modbus</strong> can provide access to all of the I/O and memory
of the PLC. In fact, it is not even necessary to run a ladder logic
program in the PLC at all. The PLC can be used as a “dumb” I/O
subsystem, with all of the logic residing in the EPICS IOC. However, if
a ladder logic program <em>is</em> being run in the PLC then the EPICS access
with <strong>modbus</strong> must be designed carefully. For example, the EPICS IOC
might be allowed to <em>read</em> any of the PLC I/O points (X inputs, Y
outputs, etc.), but <em>writes</em> could be restricted to a small range of
Control Registers, (e.g. C200-C240). The ladder logic would monitor
these control registers, considering them to be “requests” from EPICS
that should be acted upon only if it is safe to do so.</p>
<p>The architecture of the <strong>modbus</strong> module from the top-level down
consists of the following 4 layers:</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://epics-modules.github.io/master/asyn/R4-40/asynDriver.html#genericEpicsSupport">EPICS asyn device support</a>.
This is the general purpose device support provided with
<a class="reference external" href="https://github.com/epics-modules/asyn">asyn</a> There is no
special device support needed or provided with <strong>modbus</strong>.</p></li>
<li><p>An EPICS asyn port driver that functions as a Modbus client. The
<strong>modbus</strong> port driver communicates with EPICS device support (layer
1) using the standard asyn interfaces (asynUInt32Digital, asynInt32,
etc.). This driver sends and receives device-independent Modbus
frames via the standard asynOctet interface to the “interpose
interface” (layer 3). These frames are independent of the underlying
communications protocol. Prior to R3-0 this driver was written in C.
In R3-0 it was written as a C++ class that inherits from
asynPortDriver. This allows it to export its methods in a way that is
easy for other drivers to use, in particular the doModbusIO() method.</p></li>
<li><p>An asyn “interpose interface” layer that handles the additional data
required by the underlying communications layer (TCP, RTU, ASCII).
This layer communicates via the standard asynOctet interface to both
the overlying Modbus driver (layer 2) and to the underlying asyn
hardware port driver (layer 4).</p></li>
<li><p>An asyn port driver that handles the low-level communication (TCP/IP
or serial). This is one of the standard port drivers provided with
asyn, i.e.
<a class="reference external" href="https://epics-modules.github.io/master/asyn/R4-40/asynDriver.html#drvAsynIPPort">drvAsynIPPort</a>
or
<a class="reference external" href="https://epics-modules.github.io/master/asyn/R4-40/asynDriver.html#drvAsynSerialPort">drvAsynSerialPort</a>.
They are not part of the <strong>modbus</strong> module.</p></li>
</ol>
<p>Because <strong>modbus</strong> makes extensive use of existing asyn facilities, and
only needs to implement layers 2 and 3 above, the amount of code in
<strong>modbus</strong> is quite small (fewer than 3,900 lines).</p>
<p>Each <strong>modbus</strong> port driver is assigned a single Modbus function code.
Usually a drivers is also assigned a single contiguous range of Modbus
memory, up to 2000 bits or 125 words. One typically creates several
<strong>modbus</strong> port drivers for a single PLC, each driver reading or writing
a different set of discrete inputs, coils, input registers or holding
registers. For example, one might create one port driver to read
discrete inputs X0-X37, a second to read control registers C0-C377, and
a third to write control registers C300-C377. In this case the asyn
address that is used by each record is relative to the starting address
for that driver.</p>
<p>It is also possible to create a driver is allowed to address any
location in the 16-bit Modbus address space. Each read or write
operation is still limited to the 125/123 word limits. In this case the
asyn address that is used by each record is the absolute Modbus address.
This absolute addressing mode is enabled by passing -1 as the
modbusStartAddress when creating the driver.</p>
<p>The restriction the modbus port driver to a single Modbus function does
not apply to the doModbusIO() method. This method can be used for
arbitrary Modbus IO using any function code. If absolute addressing is
enabled as described above then the doModbusIO() function can also
address any Modbus memory location.</p>
<p>The behavior of the port driver differs for read function codes (1, 2,
3, 4), write function codes (5, 6, 15, 16, 17), and read/write function
codes (23).</p>
<section id="modbus-read-functions">
<h2>Modbus read functions<a class="headerlink" href="#modbus-read-functions" title="Link to this heading"></a></h2>
<p>For read function codes (when absolute addressing is not being used) the
driver spawns a poller thread. The poller thread reads the entire block
of Modbus memory assigned to this port in a single Modbus transaction.
The values are stored in a buffer in the driver. The delay between polls
is set when the port driver is created, and can be changed later at
run-time. The values are read by EPICS using the standard asyn
interfaces (asynUInt32Digital, asynInt32, asynInt64, asynFloat64, etc.) The values
that are read are the last stored values from the poller thread. The
means that EPICS read operations are <em>asynchronous</em>, i.e. they can
block. This is because although they do not directly result in Modbus
I/O, they do need to wait for a mutex that indicates that the poller
thread is done.</p>
<p>For read functions it is possible to set the EPICS records to “I/O Intr”
scanning. If this is done then the port driver will call back device
support whenever there is new data for that input. This improves
efficiency, because such records only process when needed, they do not
need to be periodically scanned.</p>
<p>The previous paragraphs describe the normal configuration for read
operations, where relative Modbus addressing is being used. If absolute
addressing is being used then the driver does not create a poller
thread, because it does not know what parts of the Modbus address space
should be polled. In this case read records cannot have SCAN=I/O Intr.
They must either be periodically scanned, or scanned by directly causing
the record to process, such as writing 1 to the .PROC field. Each time
the record processes it will result in a separate Modbus read operation.
NOTE: This is <strong>much</strong> less efficient than reading many registers at
once with relative Modbus addressing. For this reason absolute Modbus
addressing with read functions should normally be avoided.</p>
</section>
<section id="modbus-write-functions">
<h2>Modbus write functions<a class="headerlink" href="#modbus-write-functions" title="Link to this heading"></a></h2>
<p>For write function codes the driver does not itself create a separate
thread. Rather the driver does the Modbus I/O immediately in response to
the write operations on the standard asyn interfaces. This means that
EPICS write operations are also <em>asynchronous</em>, i.e. they block because
Modbus I/O is required. When the <strong>modbus</strong> driver is created it tells
asynManager that it can block, and asynManager creates a separate thread
that executes the write operations.</p>
<p>Word write operations using the asynUInt32Digital interface (with a mask
parameter that is not 0x0 or 0xFFFF) are done using read/modify/write
operations. This allows multiple Modbus clients to write and read single
words in the same block of Modbus memory. However, it <em>does not</em>
guarantee correct operation if multiple Modbus clients (or the PLC
itself) can modify bits within a single word. This is because the Modbus
server cannot perform the read/modify/write I/O as an atomic operation
at the level of the Modbus client.</p>
<p>For write operations it is possible to specify that a single read
operation should be done when the port driver is created. This is
normally used so that EPICS obtains the current value of an output
device when the IOC is initialized.</p>
<p>Modbus RTU specifies a minimum delay of 3.5 character times between
writes to the device. The modbusInterposeConfig function allows one to
specify a write delay in msec before each write.</p>
</section>
<section id="modbus-write-read-functions">
<h2>Modbus write/read functions<a class="headerlink" href="#modbus-write-read-functions" title="Link to this heading"></a></h2>
<p>Modbus function code 23 allows for writing a set of registers and
reading a set of registers in a single operation. The read operation is
performed after the write operation, and the register range to be read
can be different from the register range to be written. Function code 23
is not widely used, and the write/read operation is not a good fit to
the <strong>modbus</strong> driver model of read-only and write-only drivers.
Function code 23 is implemented in <strong>modbus</strong> with the following
restrictions:</p>
<ul class="simple">
<li><p>A driver that uses Modbus function code 23 is either <em>read-only</em> or
<em>write-only</em>.</p></li>
<li><p>A read-only driver is created by specifying function code 123 to the
drvModbusAsynConfigure command described below. The driver will use
Modbus function code 23 for the Modbus protocol. It will only read
registers (like function codes 3 and 4), it will not write any data
to the device.</p></li>
<li><p>A write-only driver is created by specifying function code 223 to the
drvModbusAsynConfigure command described below. The driver will use
Modbus function code 23 for the Modbus protocol. It will only write
registers (like function code 16), it will not read any data from the
device.</p></li>
</ul>
</section>
<section id="platform-independence">
<h2>Platform independence<a class="headerlink" href="#platform-independence" title="Link to this heading"></a></h2>
<p><strong>modbus</strong> should run on all EPICS platforms. It has been tested on
linux-x86, linux-x86_64, vxWorks-ppc32, win32-x86, windows-x64, (native
Windows with Microsoft Visual Studio C++ compiler).</p>
<p>The only thing that may be architecture dependent in <strong>modbus</strong> is the
structure packing in modbus.h. The “#pragma pack(1)” directive used
there is supported on gnu and Microsoft compilers. If this directive is
not supported on some compilers of interest then modbus.h will need to
have the appropriate architecture dependent code added.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="overview.html" class="btn btn-neutral float-left" title="Overview of Modbus" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="creating_driver.html" class="btn btn-neutral float-right" title="Creating a modbus port driver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Mark Rivers.
      <span class="lastupdated">Last updated on 2024-April-16.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>